--CREATING A DATABASE
CREATE OR REPLACE DATABASE AD_ASSIGNMENT;

-- ACTIVATING THE DATABASE
USE AD_ASSIGNMENT;

-- CREATING A TABLE
CREATE OR REPLACE TABLE AD_employees
(
    employee_id INT PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    department VARCHAR(50),
    hire_date DATE,
    salary INT
);

-- INSERING VALUE INTO ALREADY CREATED TABLE
INSERT INTO AD_employees (employee_id, first_name, last_name, department, hire_date, salary)
VALUES
(1, 'John', 'Doe', 'HR', '2020-01-15', 50000),
(2, 'Jane', 'Smith', 'IT', '2019-04-20', 60000),
(3, 'Michael', 'Johnson', 'Finance', '2021-08-10', 55000),
(4, 'Emily', 'Davis', 'Marketing', '2018-02-05', 52000),
(5, 'David', 'Wilson', 'IT', '2022-03-30', 62000);

-- CHECKING THE VALUES OF TABLE
SELECT * FROM AD_EMPLOYEES;

-- COUNTING NO OF ROWS.
SELECT COUNT(*) FROM AD_EMPLOYEES; -- 5 ROWS


-- QUESTION ANSWERS
-- 1. Retrieve the first and last names of all employees.

SELECT EMPLOYEE_ID,FIRST_NAME,LAST_NAME
FROM AD_EMPLOYEES;

-- 2. Find the total number of employees in the company.

SELECT COUNT(DISTINCT EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES
FROM AD_EMPLOYEES; -- GIVES 5 EMPLOYEES

-- 3. Get the names of employees who work in the IT department.

SELECT FIRST_NAME||' '||LAST_NAME AS NAME_OF_EMPLOYEES_IN_IT_DEPT
FROM AD_EMPLOYEES
WHERE DEPARTMENT = 'IT';

-- 4. Calculate the average salary of all employees.

SELECT COUNT(EMPLOYEE_ID) AS NO_OF_EMPLOYEES,SUM(SALARY) AS TOT_SALARY_OF_EMPLOYEES,
ROUND(TOT_SALARY_OF_EMPLOYEES/NO_OF_EMPLOYEES,0) AS AVG_SALARY_OF_EMPLOYEES
FROM AD_EMPLOYEES; -- AVG SALARY OF EMPLOYEES IS 55800.

-- 5. Find the employee with the highest salary.

-- METHOD-1
SELECT EMPLOYEE_ID, FIRST_NAME||' '||LAST_NAME AS EMPLOYEE_WITH_HIGHEST_SALARY,SALARY
FROM AD_EMPLOYEES
ORDER BY 3 DESC
LIMIT 1; -- DAVID WILSON HAS HIGHEST SALARY WITH 62000.

-- METHOD -2
SELECT EMPLOYEE_ID,FIRST_NAME||' '||LAST_NAME AS EMPLOYEE_WITH_HIGHEST_SALARY,SALARY 
FROM AD_EMPLOYEES
WHERE SALARY = (SELECT MAX(SALARY) FROM AD_EMPLOYEES);


-- 6. List the employees hired before January 1, 2021, along with their hire dates.

SELECT EMPLOYEE_ID,FIRST_NAME||' '||LAST_NAME AS EMPLOYEES_HIRED_BEFORE_2021_01_01
FROM AD_EMPLOYEES
WHERE HIRE_DATE < '2021-01-01';


------------------------------------------------------------------------------------------------------------------------------------------
-- ACTIVATING THE DATABASE
USE DATABASE AD_ASSIGNMENT;

-- CREATING A NEW TABLE STRUCTURE
CREATE OR REPLACE TABLE AD_sales 
(
order_id INT PRIMARY KEY,
customer_id INT,
product_id INT,
product_name VARCHAR(50),
quantity INT,
unit_price DECIMAL(10, 2),
order_date DATE
);

-- INSERTING VALUES INTO THE TABLE
INSERT INTO AD_sales (order_id, customer_id, product_id, product_name, quantity, unit_price, order_date)
VALUES
(1, 101, 1, 'Widget A', 5, 10.00, '2023-01-15'),
(2, 102, 2, 'Widget B', 2, 12.50, '2023-01-16'),
(3, 103, 1, 'Widget A', 3, 10.00, '2023-01-16'),
(4, 104, 3, 'Widget C', 1, 15.75, '2023-01-17'),
(5, 105, 2, 'Widget B', 4, 12.50, '2023-01-17'),
(6, 106, 1, 'Widget A', 2, 10.00, '2023-01-18'),
(7, 107, 4, 'Widget D', 3, 20.00, '2023-01-18'),
(8, 108, 2, 'Widget B', 5, 12.50, '2023-01-19'),
(9, 109, 1, 'Widget A', 1, 10.00, '2023-01-19'),
(10, 101, 3, 'Widget C', 2, 15.75, '2023-01-20');

-- CHECKING THE INSERTED DATA
SELECT * FROM AD_SALES;

-- FIND NO OF ROW
SELECT COUNT(*) FROM AD_SALES; -- 10 ROWS


-- START OF QUESTION AND ANSWERS
-- 1. Retrieve the total sales quantity and revenue for each product.

SELECT PRODUCT_ID,PRODUCT_NAME,UNIT_PRICE, SUM(QUANTITY) AS TOT_SALES,
TOT_SALES*UNIT_PRICE AS TOT_REVENUE 
FROM AD_SALES
GROUP BY 1,2,3
ORDER BY 1;

-- 2. Find the total revenue for each customer.

SELECT CUSTOMER_ID, SUM(QUANTITY*UNIT_PRICE) AS TOT_REVENUE 
FROM AD_SALES
GROUP BY 1;

-- 3. Get the products with more than 10 units sold in a single order.

SELECT DISTINCT ORDER_ID, PRODUCT_ID, PRODUCT_NAME
FROM AD_SALES
WHERE QUANTITY > 10;

-- 4. List the customers who have placed orders on at least three different dates.

SELECT CUSTOMER_ID, COUNT(DISTINCT ORDER_DATE) AS NO_OF_ORDER_DATE 
FROM AD_SALES
GROUP BY 1
HAVING NO_OF_ORDER_DATE >= 3
;

-- 5. Calculate the average unit price of products.

SELECT PRODUCT_ID, PRODUCT_NAME, ROUND(AVG(UNIT_PRICE),2) AS AVG_PRICE_OF_PRODUCT
FROM AD_SALES
GROUP BY 1,2
ORDER BY 1;

-- 6. Find the products with an average unit price greater than $12.00.

SELECT PRODUCT_ID, PRODUCT_NAME, ROUND(AVG(UNIT_PRICE),2) AS AVG_PRICE_OF_PRODUCT
FROM AD_SALES
GROUP BY 1,2
HAVING AVG_PRICE_OF_PRODUCT > 12.00
ORDER BY 1
;

-- 7. Retrieve the customers who have spent more than $100.00 in total.

SELECT CUSTOMER_ID,SUM(QUANTITY*UNIT_PRICE) AS TOT_SPEND 
FROM AD_SALES
GROUP BY 1
HAVING TOT_SPEND > 100;

-- 8. List the customers who have purchased 'Widget B' and 'Widget A' in the same order.

SELECT ORDER_ID,CUSTOMER_ID
FROM AD_SALES
WHERE PRODUCT_NAME = 'Widget A' AND PRODUCT_NAME = 'Widget B';

---------------------------------------------------------------------------------------------------------------------------------------------------------
-- ACTIVATING THE DATABASE
USE AD_ASSIGNMENT;

-- CREATING A TABLE IN DATABASE
CREATE OR REPLACE TABLE AD_customers 
(
customer_id INT PRIMARY KEY,
first_name VARCHAR(50),
last_name VARCHAR(50),
gender VARCHAR(10),
city VARCHAR(50),
age INT
);

-- INSERING VALUES INTO THE TABLE

INSERT INTO AD_customers (customer_id, first_name, last_name, gender, city, age)
VALUES
(1, 'John', 'Doe', 'Male', 'New York', 35),
(2, 'Jane', 'Smith', 'Female', 'Los Angeles', 28),
(3, 'Michael', 'Johnson', 'Male', 'Chicago', 45),
(4, 'Emily', 'Davis', 'Female', 'Houston', 22),
(5, 'David', 'Wilson', 'Male', 'Miami', 40),
(6, 'Lisa', 'Brown', 'Female', 'New York', 32),
(7, 'William', 'Lee', 'Male', 'Los Angeles', 29),
(8, 'Sarah', 'White', 'Female', 'Chicago', 50),
(9, 'James', 'Harris', 'Male', 'Houston', 37),
(10, 'Maria', 'Martin', 'Female', 'Miami', 24);

-- CHECKING IF ROWS ARE INSERTED
SELECT * FROM AD_CUSTOMERS;

-- COUNTING HE NO OF ROWS
SELECT COUNT(*) FROM AD_CUSTOMERS;

-- 1. Retrieve the first and last names of all customers.

SELECT DISTINCT CUSTOMER_ID, FIRST_NAME,LAST_NAME
FROM AD_CUSTOMERS
ORDER BY CUSTOMER_ID;

-- 2. Find the total number of customers in the dataset.

SELECT COUNT(DISTINCT CUSTOMER_ID) AS TOT_CUSTOMERS
FROM AD_CUSTOMERS;

-- 3. Get the names of male customers.

SELECT FIRST_NAME||' '||LAST_NAME AS MALE_CUSTOMER_NAME
FROM AD_CUSTOMERS
WHERE GENDER = 'Male';

-- 4. Find customers who are aged 30 or older.

SELECT CUSTOMER_ID,FIRST_NAME,LAST_NAME,AGE
FROM AD_CUSTOMERS
WHERE AGE >= 30;

-- 5. List customers from New York.

SELECT CUSTOMER_ID,FIRST_NAME,LAST_NAME,CITY
FROM AD_CUSTOMERS
WHERE UPPER(CITY) IN('NEW YORK');

-- 6. Retrieve customers whose first name starts with 'J'.

SELECT CUSTOMER_ID,FIRST_NAME,LAST_NAME
FROM AD_CUSTOMERS
WHERE UPPER(FIRST_NAME) LIKE 'J%'
;


-- 7. Find customers aged between 25 and 35 (inclusive).

SELECT CUSTOMER_ID,FIRST_NAME,LAST_NAME,AGE 
FROM AD_CUSTOMERS
WHERE AGE BETWEEN 25 AND 35;


-- 8. Get female customers from Los Angeles or male customers from Chicago.

SELECT CUSTOMER_ID,FIRST_NAME,LAST_NAME,GENDER,CITY
FROM AD_CUSTOMERS
WHERE (GENDER = 'Female' AND CITY = 'Los Angeles')OR(GENDER = 'Male' AND CITY = 'Chicago');

-- 9. List customers who are either from Miami or aged 50 or older.

SELECT CUSTOMER_ID,FIRST_NAME,LAST_NAME,CITY,AGE
FROM AD_CUSTOMERS
WHERE CITY ='Miami' OR AGE >= 50;

-- 10. Find customers with names 'John' or 'Jane' and aged less than 30.
SELECT CUSTOMER_ID,FIRST_NAME,LAST_NAME,AGE
FROM AD_CUSTOMERS
WHERE FIRST_NAME IN ('John','Jane') AND AGE <30;



-------------------------------------------------------------------------------------------------------------------------------------------------------
-- ACTIVATING THE DATABASE
USE DATABASE AD_ASSIGNMENT;

-- CREATING A TABLE
CREATE OR REPLACE TABLE AD_SPOTIFY
(
    PLAYLIST_URL VARCHAR (100),
    YEAR VARCHAR (5),
    TRACK_ID VARCHAR (50),
    TRACK_NAME VARCHAR (250),
    TRACK_POPULARITY INT,
    ALBUM VARCHAR (200),
    ARTIST_ID VARCHAR (100),
    ARTIST_NAME VARCHAR (100),
    ARTIST_GENRES VARCHAR (500),
    ARTIST_POPULARITY INT,
    DANCEABILITY DECIMAL (4,3),
    ENERGY DECIMAL (4,3),
    KEY INT,
    LOUDNESS DECIMAL (5,3),
    MODE INT,
    SPEECHINESS DECIMAL(5,4),
    ACOUSTICNESS DECIMAL(10,8),
    INSTRUMENTALNESS VARCHAR(10),
    LIVENESS DECIMAL (5,4),
    VALENCE DECIMAL (5,4),
    TEMPO DECIMAL(6,3),
    DURATION INT,
    TIME_SIGNATURE INT
);

-- CHECKING THE ENTRIES
SELECT * FROM AD_SPOTIFY LIMIT 100;

-- COUNTING NO OF ENTRIES
SELECT COUNT(*) FROM AD_SPOTIFY;

-- DESCRIBING THE TABLE
DESCRIBE TABLE AD_SPOTIFY;

-- COUNTING THE NO OF DISTINCT SONGS
SELECT COUNT(DISTINCT TRACK_ID) AS NO_OF_SONGS FROM AD_SPOTIFY;

-- COUNT NO OF DISTINCT SONGS AND SONG NAME FOR DUBLICATE TRACK NAME
SELECT COUNT(DISTINCT TRACK_ID) AS NO_OF_DISTINCT_SONGS,COUNT(DISTINCT TRACK_NAME ) AS NO_OF_DISTINCT_SONGS_NAME  FROM AD_SPOTIFY;

-- COUNTING NO OF DISTINCT ARTIST ID AND ARTIST NAME FOR DUPLICATE NAMES.
SELECT COUNT(DISTINCT ARTIST_ID) AS NO_OF_ARTIST_ID,COUNT(DISTINCT ARTIST_NAME) AS NO_OF_DISTINCT_ARTIST FROM AD_SPOTIFY;

-- 2.Number of songs on Spotify for each artist
SELECT ARTIST_ID,ARTIST_NAME, COUNT(TRACK_ID) AS NO_OF_SONGS FROM AD_SPOTIFY
GROUP BY 1,2
ORDER BY 3 DESC;

-- 3. Top 10 songs based on popularity
SELECT TRACK_ID,TRACK_NAME,TRACK_POPULARITY AS POPULARITY --
FROM AD_SPOTIFY
GROUP BY 1,2,3
ORDER BY 3 DESC
LIMIT 10;


SELECT * FROM AD_SPOTIFY
ORDER BY TEMPO DESC
LIMIT 2;

-- 4 Total number of songs on spotify based on year
SELECT YEAR,COUNT(DISTINCT TRACK_ID) AS NO_OF_TRACKS
FROM AD_SPOTIFY
GROUP BY 1
ORDER BY 1;

-- 5.Top song for each year (2000-2022) based on popularity

SELECT DISTINCT YEAR,MAX_BY(TRACK_NAME,TRACK_POPULARITY) AS POPULAR_SONG_OF_THE_YEAR,MAX(TRACK_POPULARITY) AS POPULARITY
FROM AD_SPOTIFY
GROUP BY 1
ORDER BY 1;

-- 6. Analysis based on Tempo : tempo > 121.08 -> 'Above Average Tempo' tempo = 121.08 -> 'Average Tempo' tempo < 121.08 -> 'Below Average Tempo'

SELECT TRACK_ID,TRACK_NAME,TEMPO,
CASE WHEN TEMPO > 121.08 THEN 'ABOVE AVERAGE TEMPO'
     WHEN TEMPO = 121.08 THEN 'AVERAGE TEMPO'
     WHEN TEMPO < 121.08 THEN 'BELOW AVERAGE TEMPO'
END AS TEMPO_ANALYSIS

FROM AD_SPOTIFY;

-- COUNTING TRACK_ID AMONGST TEMPO_RANGE
SELECT COUNT(*) AS NO_OF_SONGS,TEMPO_ANALYSIS
FROM (SELECT TRACK_ID,TRACK_NAME,TEMPO,
CASE WHEN TEMPO > 121.08 THEN 'ABOVE AVERAGE TEMPO'
     WHEN TEMPO = 121.08 THEN 'AVERAGE TEMPO'
     WHEN TEMPO < 121.08 THEN 'BELOW AVERAGE TEMPO'
END AS TEMPO_ANALYSIS
FROM AD_SPOTIFY)
GROUP BY 2;

--7. Songs with Highest Tempo
SELECT TRACK_ID ,TRACK_NAME,TEMPO
FROM AD_SPOTIFY
WHERE TEMPO IS NOT NULL
ORDER BY TEMPO DESC
LIMIT 1;

/* 8. Number of Songs for different Tempo Range : track_name, energy Modern_Music -> tempo BETWEEN 60.00 AND 100.00 Classical_Music -> tempo BETWEEN 100.001 AND 120.00 Dance_Music -> tempo BETWEEN 120.001 AND 150.01 HighTempo_Music -> tempo > 150.01 */

SELECT track_name,energy, CASE WHEN TEMPO BETWEEN 60.00 AND 100.00 THEN 'MODERN_MUSIC'
            WHEN TEMPO BETWEEN 100.01 AND 120.00 THEN 'CLASSICAL_MUSIC'
            WHEN TEMPO BETWEEN 120.001 AND 150.00 THEN 'DANCE_MUSIC'
            WHEN TEMPO >150.01 THEN 'HIGH_TEMPO_MUSIC'
            ELSE 'TEMPO_NOT_IN_RANGE'
        END AS TEMPO_RANGE
FROM AD_SPOTIFY
group by 1,2,3;


-- NO OF SONGS IN EACH TEMPO RANGE
SELECT TEMPO_RANGE,COUNT(TRACK_ID) AS NO_OF_SONGS 
FROM (SELECT *,CASE WHEN TEMPO BETWEEN 60.00 AND 100.00 THEN 'MODERN_MUSIC'
            WHEN TEMPO BETWEEN 100.01 AND 120.00 THEN 'CLASSICAL_MUSIC'
            WHEN TEMPO BETWEEN 120.001 AND 150.00 THEN 'DANCE_MUSIC'
            WHEN TEMPO >150.01 THEN 'HIGH_TEMPO_MUSIC'
            ELSE 'TEMPO_NOT_IN_RANGE'
        END AS TEMPO_RANGE
FROM AD_SPOTIFY)
GROUP BY 1
ORDER BY 2 DESC;

/*9. Energy Analysis : TOP 10 track_name, danceability, track_popularity energy > 0.64 -> 'Above Average Energy energy = 0.64 -> 'Average Energy’ energy < 0.64 -> 'Below Average Energy’ energy BETWEEN 0.1 AND 0.3 -> 'Calm Music'*/

SELECT TRACK_NAME,DANCEABILITY,TRACK_POPULARITY,ENERGY,
CASE WHEN ENERGY > 0.64 THEN 'ABOVE AVERAGE ENERGY'
     WHEN ENERGY = 0.64 THEN 'AVERAGE ENERGY'
     WHEN ENERGY < 0.64 THEN 'BELOW AVERAGE ENERGY'
END AS TYPE_OF_ENERGY,
CASE WHEN ENERGY BETWEEN 0.1 AND 0.3 THEN 'CALM MUSIC'
     WHEN ENERGY BETWEEN 0.301 AND 0.6 THEN 'MODERATE MUSIC'
     WHEN ENERGY > 0.6 THEN 'ENERGETIC MUSIC'
     ELSE 'NOT IN RANGE'
END AS TYPE_OF_MUSIC
FROM AD_SPOTIFY
WHERE ENERGY IS NOT NULL
GROUP BY 1,2,3,4,5,6
ORDER BY 4 DESC
LIMIT 10;

-- 10. Number of Songs for different energy ranges(above)

SELECT TYPE_OF_ENERGY,COUNT(TRACK_ID) AS NO_OF_SONGS 
FROM (SELECT *,
CASE WHEN ENERGY > 0.64 THEN 'ABOVE AVERAGE ENERGY'
     WHEN ENERGY = 0.64 THEN 'AVERAGE ENERGY'
     WHEN ENERGY < 0.64 THEN 'BELOW AVERAGE ENERGY'
END AS TYPE_OF_ENERGY
FROM AD_SPOTIFY
)
GROUP BY 1
ORDER BY 2 DESC;

-- 10. Number of Songs for different energy ranges(above)
SELECT TYPE_OF_MUSIC,COUNT(TRACK_ID)
FROM (SELECT *,
CASE WHEN ENERGY BETWEEN 0.1 AND 0.3 THEN 'CALM MUSIC'
     WHEN ENERGY BETWEEN 0.301 AND 0.6 THEN 'MODERATE MUSIC'
     WHEN ENERGY > 0.6 THEN 'ENERGETIC MUSIC'
     ELSE 'NOT IN RANGE'
END AS TYPE_OF_MUSIC
FROM AD_SPOTIFY)
GROUP BY 1
ORDER BY 1;

/*11. Danceability Analysis : Top 20 track_name, danceability danceability BETWEEN 0.69 AND 0.79 -> 'Low Danceability' (danceability BETWEEN 0.49 AND 0.68) OR (danceability BETWEEN 0.79 AND 0.89) -> 'Moderate Danceability' (danceability BETWEEN 0.39 AND 0.49) OR (danceability BETWEEN 0.89 AND 0.99) -> 'High Danceability' danceability < 0.39 OR danceability > 0.99 -> 'Cant Dance on this one'*/

SELECT TRACK_NAME,DANCEABILITY, 
CASE WHEN DANCEABILITY BETWEEN 0.69 AND 0.79 THEN 'LOW DANCEABILITY'
     WHEN DANCEABILITY BETWEEN 0.49 AND 0.68 OR DANCEABILITY BETWEEN 0.79 AND 0.89 THEN 'MODERATE DANCEABILITY'
     WHEN DANCEABILITY BETWEEN 0.39 AND 0.49 OR DANCEABILITY BETWEEN 0.89 AND 0.99 THEN 'HIGH DANCEABILITY'
     WHEN DANCEABILITY < 0.39 OR  DANCEABILITY > 0.99 THEN 'CANT DANCE ON THIS ONE'
     ELSE 'DANCEABILITY OUT OF RANGE'
END AS DANCEABILITY_TYPE
FROM AD_SPOTIFY
WHERE DANCEABILITY IS NOT NULL
GROUP BY 1,2
ORDER BY 2 DESC
LIMIT 20;


-- 12. Number of Songs for different danceability ranges(above)
SELECT DANCEABILITY_TYPE,COUNT(*) 
FROM (SELECT TRACK_NAME,DANCEABILITY, 
CASE WHEN DANCEABILITY BETWEEN 0.69 AND 0.79 THEN 'LOW DANCEABILITY'
     WHEN DANCEABILITY BETWEEN 0.49 AND 0.68 OR DANCEABILITY BETWEEN 0.79 AND 0.89 THEN 'MODERATE DANCEABILITY'
     WHEN DANCEABILITY BETWEEN 0.39 AND 0.49 OR DANCEABILITY BETWEEN 0.89 AND 0.99 THEN 'HIGH DANCEABILITY'
     WHEN DANCEABILITY < 0.39 OR  DANCEABILITY > 0.99 THEN 'CANT DANCE ON THIS ONE'
     ELSE 'DANCEABILITY OUT OF RANGE'
END AS DANCEABILITY_TYPE
FROM AD_SPOTIFY)
GROUP BY 1
ORDER BY 2 DESC;


/*13. Loudness Analysis : Top 20 track_name, loudness, loudness BETWEEN -23.00 AND -15.00 ->'Low Loudness' loudness BETWEEN -14.99 AND -6.00 -> 'Below Average Loudness' loudness BETWEEN -5.99 AND -2.90 -> 'Above Average Loudness' loudness BETWEEN -2.89 AND -1.00 -> 'Peak Loudness'*/

SELECT TRACK_NAME,LOUDNESS,
CASE WHEN LOUDNESS BETWEEN -23.00 AND -15.00 THEN 'LOW LOUDNESS'
     WHEN LOUDNESS BETWEEN -14.99 AND -6.00 THEN 'BELOW AVERAGE LOUDNESS'
     WHEN LOUDNESS BETWEEN -5.99 AND -2.90 THEN 'ABOVE AVERAGE LOUDNESS'
     WHEN LOUDNESS BETWEEN -2.89 AND -1.00 THEN 'PEAK LOUDNESS'
     ELSE 'LOUDNESS CANNOT BE DETERMINE'
END TYPE_OF_LOUDNESS
FROM AD_SPOTIFY
WHERE LOUDNESS IS NOT NULL
ORDER BY 2 DESC
LIMIT 20;


-- 14. Number of Songs for different loudness ranges(above)
SELECT TYPE_OF_LOUDNESS,COUNT(*)
FROM (SELECT *,
CASE WHEN LOUDNESS BETWEEN -23.00 AND -15.00 THEN 'LOW LOUDNESS'
     WHEN LOUDNESS BETWEEN -14.99 AND -6.00 THEN 'BELOW AVERAGE LOUDNESS'
     WHEN LOUDNESS BETWEEN -5.99 AND -2.90 THEN 'ABOVE AVERAGE LOUDNESS'
     WHEN LOUDNESS BETWEEN -2.89 AND -1.00 THEN 'PEAK LOUDNESS'
     ELSE 'LOUDNESS CANNOT BE DETERMINE'
END TYPE_OF_LOUDNESS
FROM AD_SPOTIFY)
GROUP BY 1;

/*15. Valence Analysis : Top 20 track_name, valence, track_popularity, valence > 0.535 -> Above Avg Valence valence = 0.535 -> Avg Valence valence < 0.535 -> Below Average'*/
SELECT TRACK_NAME,VALENCE,TRACK_POPULARITY,
CASE WHEN VALENCE > 0.535 THEN 'ABOVE AVG VALENCE'
     WHEN VALENCE = 0.535 THEN 'AVG VALENCE'
     WHEN VALENCE < 0.535 THEN 'BELOW AVERAGE'
     ELSE 'RANGE NOT FOUND'
END AS VALENCE_RANGE
FROM AD_SPOTIFY
WHERE VALENCE IS NOT NULL
ORDER BY 1
LIMIT 20;

-- 16. Number of Songs for different valence ranges(above)

SELECT VALENCE_RANGE,COUNT(*) 
FROM (SELECT TRACK_NAME,VALENCE,TRACK_POPULARITY,
CASE WHEN VALENCE > 0.535 THEN 'ABOVE AVG VALENCE'
     WHEN VALENCE = 0.535 THEN 'AVG VALENCE'
     WHEN VALENCE < 0.535 THEN 'BELOW AVERAGE'
     ELSE 'RANGE NOT FOUND'
END AS VALENCE_RANGE
FROM AD_SPOTIFY)
GROUP BY 1
ORDER BY 2 DESC;

/* 17. Speechiness Analsis : Top 20 track_name, speechiness, tempo, speechiness > 0.081-> Above Avg Speechiness speechiness = 0.081-> Avg Speechiness speechiness < 0.081-> Below Speechiness */

SELECT TRACK_NAME,SPEECHINESS,TEMPO,
CASE WHEN SPEECHINESS > 0.081 THEN 'ABOVE AVG SPEECHINESS'
     WHEN SPEECHINESS = 0.081 THEN 'AVG SPEECHINESS'
     WHEN SPEECHINESS < 0.081 THEN 'BELOW AVG SPEECHINESS'
     ELSE 'SPEECHINESS CANNOT BE DETERMINED'
END AS SPECCHINESS_TYPE
FROM AD_SPOTIFY
ORDER BY 1 DESC
LIMIT 20;


-- no of songs in each speechiness type
SELECT SPECCHINESS_TYPE,COUNT(*) 
FROM (SELECT *,
CASE WHEN SPEECHINESS > 0.081 THEN 'ABOVE AVG SPEECHINESS'
     WHEN SPEECHINESS = 0.081 THEN 'AVG SPEECHINESS'
     WHEN SPEECHINESS < 0.081 THEN 'BELOW AVG SPEECHINESS'
     ELSE 'SPEECHINESS CANNOT BE DETERMINED'
END AS SPECCHINESS_TYPE
FROM AD_SPOTIFY)
GROUP BY 1
ORDER BY 2 DESC;

/*18. Acoustic Analysis : DISTINCT TOP 25 track_name, album, artist_name, acousticness (acousticness BETWEEN 0 AND 0.40000 -> 'Not Acoustic' (acousticness BETWEEN 0.40001 AND 0.80000) ->'Acoustic' (acousticness BETWEEN 0.80001 AND 1) ->'Highly Acoustic' */

SELECT TRACK_NAME,ALBUM, ARTIST_NAME,ACOUSTICNESS,
CASE WHEN ACOUSTICNESS BETWEEN 0 AND 0.4000 THEN 'NOT ACOUSTIC'
     WHEN ACOUSTICNESS BETWEEN 0.40001 AND 0.8 THEN 'ACOUSTIC'
     WHEN ACOUSTICNESS BETWEEN 0.80001 AND 1 THEN 'HIGHLY ACOUSTIC'
     ELSE 'ACOUSTICNESS CANNOT BE DETERMINED'
END AS ACOUSTICITY
FROM AD_SPOTIFY
ORDER BY 1 DESC
LIMIT 25;

-- no of songs categories in each acoustic range
SELECT ACOUSTICITY, COUNT(*) FROM (SELECT TRACK_NAME,ALBUM, ARTIST_NAME,ACOUSTICNESS,
CASE WHEN ACOUSTICNESS BETWEEN 0 AND 0.4000 THEN 'NOT ACOUSTIC'
     WHEN ACOUSTICNESS BETWEEN 0.40001 AND 0.8 THEN 'ACOUSTIC'
     WHEN ACOUSTICNESS BETWEEN 0.80001 AND 1 THEN 'HIGHLY ACOUSTIC'
     ELSE 'ACOUSTICNESS CANNOT BE DETERMINED'
END AS ACOUSTICITY
FROM AD_SPOTIFY)
GROUP BY 1;